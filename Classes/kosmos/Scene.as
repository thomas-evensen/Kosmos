dynamic class kosmos.Scene{	var a_member:Array;	var n_focalLength:Number;	var m_el:MovieClip;	var o_axisRotation:Object;	var v_interval;	var b_doManual:Boolean;	var b_manualMove:Boolean;	var b_doRotate:Boolean;	var b_doHoover:Boolean;	var n_endSlide:Number;		public function Scene(p_x:Number,p_y:Number,p_z:Number,p_d:Number,p_f:Number)	{	    m_el = _root.createEmptyMovieClip("theScene", p_d);	    	    m_el._x = p_x;	    m_el._y = p_y;	    m_el._z = p_z;	    	    n_focalLength 	= p_f;	    o_axisRotation 	= new kosmos.math.Point(0,0,0);	    	    a_member 		= new Array();	    	    v_interval 		= false;	    	    b_doManual 		= true;	    b_manualMove	= false;	    b_doRotate		= true;	    b_doHoover		= true;	    	    n_endSlide		= 0	    	    // start the rotation	    m_el.onEnterFrame = function()	    {	    	_root.Kosmos.scene.rotate();	    }	}		// member methods	public function addMember(p_id:String, p_depth:Number):Void	{	    a_member[a_member.length] = new kosmos.visual.Dot(p_id, p_depth);	}	public function member(p_id:Number)	{	    if(p_id==null) return a_member; else return a_member[p_id];	}		public function rotate()	{		    if(b_doRotate)	    {	    	if(b_manualMove)	    	{	    		o_axisRotation.y -= m_el._xmouse/3000;	    		o_axisRotation.x += m_el._ymouse/3000;	    	}	    	else	    	{	    		o_axisRotation.y -= .005;	    	}	    		    	var screenPoints = Transform3DPointsTo2DPoints();		    	// set some values outside the loop	    	var cP 	= _root.Kosmos.currPerson.id;	    	var P 	= (_root.Kosmos.currKosmos == "project")?true:false;						// do the visual changes			for (i=0; i < a_member.length; i++)			{								a_member[i].el._x = screenPoints[i].x;				a_member[i].el._y = screenPoints[i].y;				a_member[i].el.swapDepths(screenPoints[i].z);					// if current dot is the current persondot and we're not in the project kosmos..then set scale manually				if(a_member[i].id != cP || P) 				{					a_member[i].el._xscale = a_member[i].el._yscale = 100 * screenPoints[i].scaleRatio;				}				else				{					a_member[i].el._xscale = a_member[i].el._yscale = 200;				}					}		}	}		public function Transform3DPointsTo2DPoints()	{		var TransformedPointsArray = new Array();		var sx = Math.sin(o_axisRotation.x);		var cx = Math.cos(o_axisRotation.x);		var sy = Math.sin(o_axisRotation.y);		var cy = Math.cos(o_axisRotation.y);		var sz = Math.sin(o_axisRotation.z);		var cz = Math.cos(o_axisRotation.z);		var x,y,z, xy,xz, yx,yz, zx,zy, scaleRatio;		var i = a_member.length;		while (i--)		{			x = a_member[i].pos.x;			y = a_member[i].pos.y;			z = a_member[i].pos.z;				// rotation around x			xy = cx*y - sx*z;			xz = sx*y + cx*z;			// rotation around y			yz = cy*xz - sy*x;			yx = sy*xz + cy*x;			// rotation around z			zx = cz*yx - sz*xy;			zy = sz*yx + cz*xy;								scaleRatio = n_focalLength/(n_focalLength + yz);			x = zx*scaleRatio;			y = zy*scaleRatio;			z = yz;				TransformedPointsArray[i] = new kosmos.math.Point(x, y, -z);			TransformedPointsArray[i].scaleRatio = scaleRatio;		}		return TransformedPointsArray;	}				public function endSlide()	{		n_endSlide ++;		if(n_endSlide == _root.Crew.personList().length)		{			_root.Kosmos.sliding 		= false;			n_endSlide = 0;		}	}		public function get el():MovieClip			{	return m_el;				} 	public function get doManual():Boolean		{	return b_doManual;		} 	public function set doManual(p_b:Boolean)	{	b_doManual = p_b;		} 	public function get manualMove():Boolean		{	return b_manualMove;		} 	public function set manualMove(p_b:Boolean)	{	b_manualMove = p_b;		} 	public function get doHoover():Boolean		{	return b_doHoover;		} 	public function set doHoover(p_b:Boolean)	{	b_doHoover = p_b;		} 	public function get doRotate():Boolean		{	return b_doRotate;		} 	public function set doRotate(p_b:Boolean)	{	b_doRotate = p_b;		} }